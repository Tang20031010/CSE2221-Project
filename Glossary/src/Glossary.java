import java.util.Comparator;

import components.map.Map;
import components.map.Map1L;
import components.queue.Queue;
import components.queue.Queue1L;
import components.set.Set;
import components.set.Set1L;
import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;

/**
 * This project will read from file to generate HTML pages, including a index
 * page, and several pages for words and their definitions. There will also be
 * link from some term of a word definition to another HTML page for word
 * definition.
 *
 * @author Coney Tang
 */
public final class Glossary {

    /**
     * Default constructor--private to prevent instantiation.
     */
    private Glossary() {
        // no code needed here
    }

    /**
     * Compare {@code String}s in lexicographic order.
     */
    private static class StringLT implements Comparator<String> {
        @Override
        public int compare(String o1, String o2) {
            return o1.compareTo(o2);
        }
    }

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * <html> <head> <title>Glossary</title> </head> <body>
     * <h2>Glossary</h2>
     * <hr>
     * <h3>Index</h3>
     * <ul>
     *
     * @param title
     *            HTML page title
     * @param out
     *            The output stream
     *
     * @updates out.content
     *
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void outputHeader(String title, SimpleWriter out) {
        assert title != null : "Violation of: title is not null";
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";

        /*
         * Output the "opening" tags in the generated HTML file
         */
        out.println("<html>");
        out.println("  <head>");
        out.println("    <title>" + title + "</title>");
        out.println("  </head>");
        out.println("  <body>");
        out.println("    <h2>" + title + "</h2>");
        out.println("    <hr>");
        out.println("    <h3>" + "Index" + "</h3>");
        out.println("    <ul>");
    }

    /**
     * Outputs the "closing" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * </ul>
     * </body> </html>
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    private static void outputFooter(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";

        /*
         * Output the close tag of HTML file
         */
        out.println("    </ul>");
        out.println("  </body>");
        out.println("</html>");
    }

    /**
     * Generates the set of characters in the given {@code String} into the
     * given {@code Set}.
     *
     * @param str
     *            the given {@code String}
     * @param charSet
     *            the {@code Set} to be replaced
     * @replaces charSet
     * @ensures charSet = entries(str)
     */
    private static void generateElements(String str, Set<Character> charSet) {
        assert str != null : "Violation of: str is not null";
        assert charSet != null : "Violation of: charSet is not null";
        /*
         * Declare and initialize temp
         */
        Set<Character> temp = new Set1L<>();
        /*
         * Iterate through the str
         */
        for (int i = 0; i < str.length(); i++) {
            /*
             * if the character in string is not contained in temp, add it to
             * set
             */
            if (!temp.contains(str.charAt(i))) {
                temp.add(str.charAt(i));
            }
        }
        /*
         * restore charSets
         */
        charSet.transferFrom(temp);
    }

    /**
     * Returns the first "word" (maximal length string of characters not in
     * {@code separators}) or "separator string" (maximal length string of
     * characters in {@code separators}) in the given {@code text} starting at
     * the given {@code position}.
     *
     * @param text
     *            the {@code String} from which to get the word or separator
     *            string
     * @param position
     *            the starting index
     * @param s
     *            the {@code Set} of separator characters
     * @return the first word or separator string found in {@code text} starting
     *         at index {@code position}
     * @requires 0 <= position < |text|
     * @ensures <pre>
     * nextWordOrSeparator =
     *   text[position, position + |nextWordOrSeparator|)  and
     * if entries(text[position, position + 1)) intersection separators = {}
     * then
     *   entries(nextWordOrSeparator) intersection separators = {}  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      intersection separators /= {})
     * else
     *   entries(nextWordOrSeparator) is subset of separators  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      is not subset of separators)
     * </pre>
     */
    private static String nextWordOrSeparator(String text, int position,
            Set<Character> s) {
        assert text != null : "Violation of: text is not null";
        assert s != null : "Violation of: separators is not null";
        assert 0 <= position : "Violation of: 0 <= position";
        assert position < text.length() : "Violation of: position < |text|";

        /*
         * Declare and initialize str
         */
        String str = "";
        /*
         * Declare and initialize temp to check and store if s contains the
         * character in text is at the position
         */
        boolean temp = s.contains(text.charAt(position));
        /*
         * Declare and initialize count as position
         */
        int count = position;
        /*
         * Iterate and check if count is less than the length of text and if the
         * character is the same category of the character at position
         */
        while (count < text.length()
                && s.contains(text.charAt(count)) == temp) {
            count++;
        }
        /*
         * Let str be the longest string of the consistent same category
         * characters
         */
        str = text.substring(position, count);
        /*
         * Return statement
         */
        return str;
    }

    /**
     * Inputs a "glossary" of words (items) and their definitions from the given
     * file and stores them in the given {@code Map}.
     *
     * @param wordDefinition
     *            word->definition
     * @param in
     *            input stream
     *
     * @replaces wordDefinition
     * @requires <pre>
     * in.is_open and
     * [in.content begins with a term with its definition on the next
     *  line or next several lines, followed by a empty line and then a word
     *  in the next line]
     * </pre>
     * @ensure [wordDefinition contains word -> definition mapping from input
     *         stream in]
     */
    public static void wordDefinitionMapping(Map<String, String> wordDefinition,
            SimpleReader in) {
        assert in != null : "Violation of: input is not null";
        assert in.isOpen() : "Violation of: in.is_open";
        assert wordDefinition != null : "Violation of : wordDefinition is not null";
        /*
         * Iterate through the whole file
         */
        while (!in.atEOS()) {
            /*
             * Declare and initialize word
             */
            String word = in.nextLine();
            /*
             * Declare and initialize word
             */
            String temp = in.nextLine();
            /*
             * Declare and initialize definition
             */
            StringBuilder definition = new StringBuilder();
            /*
             * Iterate and check if the next line will be empty
             */
            while (!temp.equals("")) {
                /*
                 * If not, definition adds the next line string and a space
                 */
                definition.append(temp);
                definition.append(" ");
                temp = in.nextLine();
            }
            /*
             * Add the word and corresponding definition to the wordDefinition
             * map
             */
            wordDefinition.add(word, definition.toString());
        }
    }

    /**
     * Return the minimum key value from {@code Map} according to the ordering
     * provided by the {@code compare} method from {@code orderComp}.
     *
     * @param wordDefinition
     *            word -> definition
     * @return the minimum value of key of {@code Map}
     * @requires <pre>
     * {@code Map} is formed as word->definition and
     *   [the relation computed by order.compare is a total preorder]
     * </pre>
     * @ensures [Gets the keys in {@code Map}, put them in Queue order, sort
     *          order in lexicographic order, and then return the minimum
     *          string]
     */
    public static String lexicographicOrder(
            Map<String, String> wordDefinition) {
        assert wordDefinition != null : "Violation of: wordDefinition is not null";
        /*
         * Declare and initialize order
         */
        Queue<String> order = new Queue1L<>();
        /*
         * Declare and initialize temp
         */
        Map<String, String> temp = new Map1L<>();
        /*
         * Iterate through wordDefinition
         */
        while (wordDefinition.size() > 0) {
            /*
             * Declare and initialize pair
             */
            Map.Pair<String, String> pair = wordDefinition.removeAny();
            /*
             * Declare and initialize key to store the key of pair
             */
            String key = pair.key();
            /*
             * Declare and initialize value to store the value of pair
             */
            String value = pair.value();

            /*
             * Add the key to the Queue order
             */
            order.enqueue(key);
            /*
             * Add the pair to temp
             */
            temp.add(key, value);
        }
        /*
         * Restore wordDefinition
         */
        wordDefinition.transferFrom(temp);
        /*
         * Declare and initialize orderComp
         */
        Comparator<String> orderComp = new StringLT();
        /*
         * Sort the Queue order
         */
        order.sort(orderComp);

        /*
         * Get a element which is in lexicographic order in the Queue
         */
        String result = order.dequeue();
        /*
         * Return statement
         */
        return result;
    }

    /**
     * Processes words in lexicographic order in the index page and link each of
     * them to their own definition page.
     *
     * @param wordDefinition
     *            word->definition
     * @param out
     *            the output stream
     * @updates out.content
     * @requires <pre>
     * out.is_open and
     * [{@code Map} is formed as word->definition]
     * </pre>
     * @ensures <pre>
     * out.content = #out.content *
     *   [an HTML list of keys of wordDefinition in lexicographic order]
     * </pre>
     */
    public static void processWord(Map<String, String> wordDefinition,
            SimpleWriter out) {
        assert wordDefinition != null : "Violation of: wordDefinition is not null";
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";
        /*
         * Declare and initialize tempMap
         */
        Map<String, String> tempMap = new Map1L<>();
        /*
         * Iterate through wordDefinition
         */
        while (wordDefinition.size() > 0) {
            /*
             * Call lexicographicOrder to get elements in lexicographic order
             */
            String min = lexicographicOrder(wordDefinition);
            /*
             * Declare and initialize temp
             */
            Map.Pair<String, String> temp = wordDefinition.remove(min);
            /*
             * Declare and initialize key to store the key of temp
             */
            String word = temp.key();
            /*
             * Declare and initialize value to store the value of temp
             */
            String definition = temp.value();

            /*
             * Output the elements in the index file
             */
            out.println("      <li>");
            out.println(
                    "        <a href = \"" + word + ".html\">" + word + "</a>");
            out.println("      </li>");
            /*
             * Add the temp to tempMap
             */
            tempMap.add(word, definition);
        }
        /*
         * Restore wordDefinition
         */
        wordDefinition.transferFrom(tempMap);

    }

    /**
     * Outputs the HTML tags for each term, its definition, and a link to index
     * page. If there is words in the definition that is the same as any other
     * words in key of the {@code Map} there will be a link directed to those
     * words' HTML page.
     *
     * <html> <head> <title>word</title> </head> <body>
     * <h2>word</h2>
     * <hr>
     * <p>
     * <font color = "red"> + word + "</font>
     * </p>
     * "Return to"<a href = "index.html"> Index </a> </body> </html>
     *
     * @param wordDefinition
     *            word -> definition map
     * @param s
     *            set of characters
     *
     * @requires {@code Map} is formed as word->definition
     * @ensures <pre>
     * out.content = #out.content *
     *   [the HTML "opening" tags, link
     *   directed to the index page, link directed to the HTML page of
     *   word in the definition that is the same with other keys in the
     *   {@code Map}, and the HTML "closing" tags]
     *  </pre>
     */
    public static void wordPage(Map<String, String> wordDefinition,
            Set<Character> s) {
        assert wordDefinition != null : "Violation of: wordDefinition is not null";
        assert s != null : "Violation of: s is not null";
        /*
         * Declare and initialize tempMap
         */
        Map<String, String> tempMap = new Map1L<>();
        /*
         * Iterate through wordDefinition
         */
        while (wordDefinition.size() > 0) {
            /*
             * Declare and initialize temp
             */
            Map.Pair<String, String> temp = wordDefinition.removeAny();
            /*
             * Declare and initialize word to store the key of temp
             */
            String word = temp.key();
            /*
             * Declare and initialize definition to store the value of temp
             */
            String definition = temp.value();

            /*
             * Add temp to tempMap
             */
            tempMap.add(word, definition);
            /*
             * Open output stream
             */
            SimpleWriter out = new SimpleWriter1L(word + ".html");

            /*
             * Output the HTML file
             */
            out.println("<html>");
            out.println("  <head>");
            out.println("    <title>" + word + "</title>");
            out.println("  </head>");
            out.println("  <body>");
            out.println("    <h2>");
            out.println("      <b>");
            out.println("        <i>");
            out.println("          <font color = \"red\">" + word + "</font>");
            out.println("        </i>");
            out.println("      </b>");
            out.println("    </h2>");
            out.println("      <blockquote>");
            /*
             * Iterate through the string definition
             */
            for (int i = 0; i < definition.length(); i++) {
                /*
                 * Declare and initialize wordTemp to store the return value of
                 * the nextWordOrSeparator method
                 */
                String wordTemp = nextWordOrSeparator(definition, i, s);
                /*
                 * If the wordTemp is a key in wordDefinition, create a link to
                 * the wordTemp's own HTML page, else print the word
                 */
                if (wordDefinition.hasKey(wordTemp)) {
                    out.print(" <a href = \"" + wordTemp + ".html\">" + wordTemp
                            + "</a>");
                } else {
                    out.print(wordTemp);
                }
                i += wordTemp.length() - 1;
            }
            out.println();
            out.println("      </blockquote>");
            out.println("    <hr />");
            out.println("      <p>");
            out.println(
                    "        Return to <a href = \"index.html\"> Index </a>");
            out.println("      </p>");
            out.println("  </body>");
            out.println("</html>");
            /*
             * Close output stream
             */
            out.close();

        }
        /*
         * Restore wordDefinition
         */
        wordDefinition.transferFrom(tempMap);
    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments; unused here
     */
    public static void main(String[] args) {
        /*
         * Open the input and output stream
         */
        SimpleWriter out = new SimpleWriter1L();
        SimpleReader in = new SimpleReader1L();

        /*
         * Ask user for a file
         */
        out.println("Input file: ");
        String file = in.nextLine();

        /*
         * Open the input stream as fileIn
         */
        SimpleReader fileIn = new SimpleReader1L(file);
        /*
         * Open the output stream as index
         */
        SimpleWriter index = new SimpleWriter1L("index.html");
        /*
         * Declare and initialize wordDefinition
         */
        Map<String, String> wordDefinition = new Map1L<>();
        /*
         * Call the wordDefinitionMapping method
         */
        wordDefinitionMapping(wordDefinition, fileIn);

        /*
         * Declare and initialize s to store some separators
         */
        Set<Character> s = new Set1L<>();
        /*
         * Declare and initialize charSet
         */
        String charSet = "? ;:!-()~/<>\"";
        /*
         * Call the generateElements method
         */
        generateElements(charSet, s);

        /*
         * Call wordPage method
         */
        wordPage(wordDefinition, s);
        /*
         * Call outputHeader method
         */
        outputHeader("Glossary", index);
        /*
         * Call processWord method
         */
        processWord(wordDefinition, index);
        /*
         * Call outputFooter method
         */
        outputFooter(index);

        /*
         * close input and output stream
         */
        in.close();
        out.close();
        index.close();
        fileIn.close();
    }
}
